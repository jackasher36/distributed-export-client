# 通用导出框架使用指南

## 概述

这个通用导出框架解决了原有代码中每种数据类型都需要重复实现相同导出逻辑的问题。现在只需要实现几个简单的接口，就能快速为任意数据类型添加完整的导出功能。

## 框架优势

1. **大幅减少重复代码**: 原来的 IrMessageExportProcessor 有443行代码，现在只需要50行
2. **高度可复用**: 异步处理、分页、分组、进度监控等逻辑完全复用
3. **类型安全**: 基于泛型设计，编译时类型检查
4. **易于扩展**: 新增数据类型只需实现3个核心接口
5. **配置灵活**: 支持统一的导出参数配置

## 核心组件

### 1. 通用基类
- `GenericExportProcessor<QUERY, DATA, VIEW>`: 导出处理器基类
- `GenericBatchDataProcessingService<DATA, QUERY>`: 通用批处理服务

### 2. 核心接口
- `GenericExportQuery`: 查询参数接口
- `GenericDataAccessor<QUERY, DATA>`: 数据访问接口
- `GenericDataConverter<DATA, VIEW>`: 数据转换接口  
- `GenericBatchProcessor<DATA, QUERY>`: 批处理接口
- `GenericBatchProcessingDispatcher`: 通用批处理调度器

## 快速开始

### 步骤1: 创建查询类
```java
@Data
public class YourDataQuery implements Serializable, GenericExportQuery {
    private ExportParams exportParams;
    // 你的查询条件字段...
    
    public YourDataQuery() {
        this.exportParams = new ExportParams();
    }
}
```

### 步骤2: 实现数据访问器

```java
@Component
public class YourDataAccessor implements GenericDataAccessor<YourDataQuery, YourData> {
    
    @Override
    public Long countByQuery(YourDataQuery query) {
        // 实现总数查询逻辑
    }
    
    @Override
    public List<YourData> queryByPage(YourDataQuery query, long offset, int size) {
        // 实现分页查询逻辑
    }
}
```

### 步骤3: 实现数据转换器
```java
@Component
public class YourDataConverter implements GenericDataConverter<YourData, YourView> {
    
    @Override
    public YourView convertToView(YourData data) {
        // 实现数据转视图逻辑
    }
}
```

### 步骤4: 实现批处理器
```java
@Component
public class YourBatchProcessor implements GenericBatchProcessor<YourData, YourDataQuery> {
    
    @Override
    public void processBatchData(List<YourData> dataList, String subTaskId, 
                                int pageNum, YourDataQuery query, String mainTaskId) {
        // 实现批处理逻辑（可选，如果不需要批处理可以留空）
        
        // 简单的数据处理示例
        for (YourData data : dataList) {
            // 处理每条数据，比如：
            // - 数据校验
            // - 数据补充
            // - 文件处理
            // - 发送通知等
            log.info("处理数据: {}", data.getId());
        }
    }
}
```

### 步骤5: 创建导出处理器
```java
@Component
@ExportSpecification(
    code = "YourDataExportProcessor",
    name = "你的数据导出处理器", 
    executeType = ExecuteType.CLUSTER
)
public class YourDataExportProcessor extends GenericExportProcessor<YourDataQuery, YourData, YourView> {

    @Resource
    private YourDataAccessor dataAccessor;
    
    @Resource
    private YourDataConverter dataConverter;
    
    @Resource
    private YourBatchProcessor batchProcessor;

    @Override
    protected GenericDataAccessor<YourDataQuery, YourData> getDataAccessor() {
        return dataAccessor;
    }

    @Override
    protected GenericDataConverter<YourData, YourView> getDataConverter() {
        return dataConverter;
    }

    @Override
    protected GenericBatchProcessor<YourData, YourDataQuery> getBatchProcessor() {
        return batchProcessor;
    }

    @Override
    protected Class<YourView> getViewClass() {
        return YourView.class;
    }

    @Override
    protected String getExportCode() {
        return "YourData";
    }
}
```

## 示例对比

### 原有方式 (IrMessageExportProcessor.java - 443行)
```java
// 需要重复实现：
// - taskRuntimeConfig() - 30行
// - totalCount() - 35行  
// - getHeaders() - 60行
// - queryData() - 50行
// - convert() - 40行
// - group() - 150行
// - 各种配置解析逻辑 - 80行
// 总计: 445行重复代码
```

### 新方式 (UserExportProcessor.java - 50行)
```java
// 只需要实现：
// - 注入3个核心组件 - 10行
// - 覆盖5个抽象方法 - 25行  
// - 注解和类声明 - 15行
// 总计: 50行简洁代码
```

## 配置说明

所有导出参数都通过 `ExportParams` 统一配置：

```java
ExportParams params = new ExportParams();
params.setPageRowNumber(1000);     // 分页大小
params.setTotalCount(50000);       // 最大导出数量
params.setSheetRowNumber(10000);   // 每个Sheet行数
params.setProcessAttachments(true); // 是否处理附件
// ... 其他配置
```

## 框架特性

### 1. 自动分页分组
- 框架自动处理数据分页
- 智能分配数据到不同Sheet
- 支持跨子任务的全局Sheet索引

### 2. 多种批处理模式
- **SYNC**: 同步处理，阻塞当前线程
- **ASYNC**: 异步处理，使用线程池
- **DEFERRED**: 延迟处理，等主任务完成后执行
- **NONE**: 跳过批处理
- **自定义模式**: 支持MQ、Kafka等消息队列模式

### 3. 通用批处理调度器
- `GenericBatchProcessingDispatcher` 提供统一的调度逻辑
- 支持降级处理：MQ/Kafka失败时自动降级为异步模式
- 线程池隔离，避免相互影响
- 内置超时控制机制

### 4. 进度监控
- 实时进度跟踪
- 错误统计和报告
- 任务状态管理

### 5. 容错设计
- 批处理失败不影响Excel生成
- 优雅降级处理
- 详细的错误日志

## 最佳实践

1. **数据访问器**: 使用连接池和分页查询，避免大结果集
2. **批处理器**: 保持幂等性，支持重试机制
3. **数据转换**: 避免复杂计算，保持轻量级转换
4. **错误处理**: 记录详细日志，但不中断主流程
5. **性能优化**: 合理设置分页大小和线程池参数

## 扩展点

框架提供了多个扩展点供自定义：

1. **配置解析**: 覆盖 `resolveXxx()` 方法自定义配置逻辑
2. **表头生成**: 覆盖 `getHeaders()` 方法自定义表头
3. **分组策略**: 覆盖 `group()` 方法自定义分组逻辑
4. **超时控制**: 通过 `processDataAsync()` 参数控制超时时间

这个框架让你专注于业务逻辑，而不用关心复杂的导出流程实现！
